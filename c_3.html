<!-- c_3.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C언어 기초 3 - ThisKorea81</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
        }
        .code-block {
            background-color: #2D3748;
            color: #E2E8F0;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .interactive-box {
            background-color: #FFFFFF;
            border: 1px solid #E2E8F0;
            border-radius: 0.5rem;
            padding: 1.5rem;
        }
        .memory-box {
            border: 2px solid #A0AEC0;
            padding: 0.75rem;
            border-radius: 0.25rem;
            background-color: #F7FAFC;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .address {
            font-size: 0.75rem;
            color: #718096;
            font-family: monospace;
        }
        .value {
            font-size: 1.25rem;
            font-weight: 700;
            color: #4A5568;
        }
        .hanoi-canvas {
            border: 1px solid #CBD5E0;
            background-color: #FFFFFF;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        .array-cell-pointer {
            border: 2px solid #4F46E5 !important;
            box-shadow: 0 0 10px #4F46E5;
        }
        .ds-viz {
            min-height: 80px;
            background-color: #F7FAFC;
            border-radius: 0.5rem;
            border: 1px solid #EDF2F7;
            padding: 1rem;
            display: flex;
            align-items: center;
            overflow-x: auto;
        }
        .ds-node, .ds-item {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 60px;
            height: 60px;
            border: 2px solid #4A5568;
            border-radius: 0.25rem;
            font-weight: bold;
            background-color: white;
        }
        .ds-arrow {
            font-size: 2rem;
            color: #718096;
            margin: 0 0.5rem;
        }
        .stack-viz {
            flex-direction: column-reverse;
            min-height: 240px;
            width: 100px;
            margin: 0 auto;
            gap: 4px;
        }
        .struct-array-item {
            border: 1px solid #C4B5FD;
            padding: 0.5rem;
            margin: 0.5rem;
            border-radius: 0.25rem;
            background-color: #F5F3FF;
        }
        .struct-array-viz {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .union-memory-slot {
            border: 2px solid #5A67D8;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #F0F4FF;
            text-align: center;
            position: relative;
        }
        .union-memory-slot .label {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            font-size: 0.75rem;
            color: #5A67D8;
            font-weight: bold;
        }
        .union-memory-slot .current-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2C3E50;
            margin-top: 1.5rem;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- 헤더 & 네비게이션 바 -->
    <header class="bg-white/90 backdrop-blur-lg sticky top-0 z-50 shadow-sm border-b border-slate-200">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="index.html" class="text-2xl font-bold text-indigo-600">ThisKorea81</a>
            <div class="hidden md:flex items-center space-x-2">
                <a href="class.html" class="font-semibold text-indigo-600 bg-indigo-50 py-2 px-4 rounded-lg">수업</a>
                <a href="computer_vision.html" class="font-semibold text-slate-700 hover:text-indigo-600 py-2 px-4 rounded-lg transition-colors">컴퓨터비전</a>
                <a href="natural_language_processing.html" class="font-semibold text-slate-700 hover:text-indigo-600 py-2 px-4 rounded-lg transition-colors">자연어처리</a>
                <a href="project.html" class="font-semibold text-slate-700 hover:text-indigo-600 py-2 px-4 rounded-lg transition-colors">프로젝트</a>
            </div>
            <div class="md:hidden">
                <button class="text-slate-700 focus:outline-none">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
            </div>
        </nav>
    </header>

    <!-- 메인 컨텐츠 -->
    <main class="container mx-auto p-6 md:p-10">
        <div class="max-w-6xl mx-auto py-12">
            <section id="intro" class="text-center mb-20">
                <h1 class="text-4xl md:text-5xl font-bold text-gray-900 leading-tight mb-4">C언어 핵심 마스터: 배열, 포인터, 함수</h1>
                <p class="max-w-3xl mx-auto text-lg text-gray-600">
                    C언어의 강력한 기능인 배열, 포인터, 함수에 대해 학습합니다. 이 가이드는 복잡한 개념을 시각적으로 이해할 수 있도록 돕습니다.
                </p>
            </section>
    
            <div id="interactive-content-placeholder">
                <!-- Part 1: 1D Array --><section id="part1" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 1. 1차원 배열: 데이터 기차 🚂</h2>
                    <p class="text-lg text-gray-600 mb-6">같은 종류의 데이터를 순서대로 묶어 관리하는 가장 기본적인 자료 구조입니다. 1차원 배열을 통해 여러 개의 데이터를 효율적으로 다루는 방법을 배워봅시다.</p>
                    <div class="interactive-box">
                        <h3 class="text-xl font-semibold mb-4">배열 시각화</h3>
                        <p class="mb-4">아래 배열의 각 칸에 마우스를 올려 인덱스와 값을 확인해보세요. C언어에서 배열의 인덱스는 항상 <span class="font-bold text-indigo-600">0</span>부터 시작합니다.</p>
                        <div id="array-viz" class="flex flex-wrap gap-2 items-center justify-center p-4 bg-gray-50 rounded-lg"></div>
                        <div id="array-tooltip" class="mt-4 text-center font-mono p-2 bg-yellow-100 text-yellow-800 rounded-md h-10 flex items-center justify-center"></div>
                    </div>
                    <h3 class="text-2xl font-bold mt-8 mb-4">핵심 문법</h3>
                    <div class="code-block">#include &lt;stdio.h&gt;

int main() {
    // int형 데이터 5개를 담는 배열 선언 및 초기화
    int scores[5] = {88, 95, 76, 100, 81};
    int total = 0;
    
    // for문을 이용해 0번부터 4번 인덱스까지 순회
    for (int i = 0; i < 5; i++) {
        // scores[i] 형태로 각 요소에 접근
        total += scores[i];
    }
    
    printf("총점: %d\n", total);
    printf("평균: %.2f\n", (double)total / 5);
    
    return 0;
}</div>
                    <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 1</h4>
                        <p class="mt-2 text-gray-700">정수 10개를 저장할 수 있는 배열을 만들고 사용자로부터 10개의 숫자를 입력받아, 그 중 **가장 큰 값**과 **가장 작은 값**을 찾아 출력하는 프로그램을 작성해보세요.</p>
                    </div>
                </section>

                <!-- Part 2: Pointer --><section id="part2" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 2. 포인터: 메모리 보물 지도 🗺️</h2>
                    <p class="text-lg text-gray-600 mb-6">포인터는 C언어의 핵심이자 가장 강력한 기능입니다. 변수의 값이 아닌 '주소'를 다루는 방법을 이해하면 메모리를 직접 제어하는 강력한 프로그래밍이 가능해집니다.</p>
                    <div class="interactive-box mb-8">
                        <h3 class="text-xl font-semibold mb-4">포인터 기초 상호작용</h3>
                        <p class="mb-4">아래 버튼을 눌러 포인터가 메모리 주소를 할당받고, 그 주소를 통해 원본 값을 어떻게 변경하는지 단계별로 확인해보세요.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                            <div class="memory-box text-center">
                                <span class="font-semibold">변수 `treasure`</span>
                                <span class="address" id="treasure-address"></span>
                                <span class="value" id="treasure-value">100</span>
                            </div>
                            <div class="memory-box text-center">
                                <span class="font-semibold">포인터 `*p_map`</span>
                                <span class="address" id="pmap-address"></span>
                                <span class="value" id="pmap-value">?</span>
                            </div>
                        </div>
                        <div class="mt-6 flex flex-wrap gap-3 justify-center">
                            <button id="ptr-step1" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">1. 주소 할당 (`p_map = &treasure`)</button>
                            <button id="ptr-step2" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition" disabled>2. 값 변경 (`*p_map = 250`)</button>
                            <button id="ptr-reset" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">초기화</button>
                        </div>
                        <p id="ptr-log" class="mt-4 text-center font-mono p-2 bg-blue-100 text-blue-800 rounded-md h-10 flex items-center justify-center"></p>
                    </div>
                    <div class="mt-10">
                        <h3 class="text-2xl font-bold mb-4">2.1. 포인터와 배열: 뗄 수 없는 관계</h3>
                        <p class="mb-4">C언어에서 배열의 이름은 사실 **배열의 첫 번째 요소의 메모리 주소를 가리키는 상수 포인터**입니다. 이 특징 때문에 포인터와 배열은 매우 밀접하게 사용됩니다.</p>
                        <div class="code-block">// scores 배열이 선언되었을 때
int scores[5] = {10, 20, 30, 40, 50};

// `scores`는 배열의 첫 번째 요소의 주소와 같습니다.
printf("%p\n", scores);      // 첫 번째 요소의 주소 출력
printf("%p\n", &scores[0]);  // 위와 동일한 주소 출력

// 포인터를 이용해 배열 요소에 접근하기
int *ptr = scores; // 포인터에 배열의 시작 주소를 할당

// `*(ptr + i)`는 `scores[i]`와 정확히 같습니다.
printf("%d\n", *(ptr + 2)); // 30 출력 (scores[2]와 동일)
</div>
                    </div>
                    <div class="interactive-box mt-8">
                        <h3 class="text-xl font-semibold mb-4">포인터로 배열 탐색하기</h3>
                        <p class="mb-4">포인터 연산(`p++`)을 통해 배열의 각 요소를 순서대로 가리킬 수 있습니다. 아래 버튼을 눌러 포인터가 배열을 어떻게 이동하는지 확인해보세요.</p>
                        <div id="ptr-array-viz" class="flex flex-wrap gap-2 items-center justify-center p-4 bg-gray-50 rounded-lg mb-4"></div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                            <div class="memory-box text-center">
                                <span class="font-semibold">포인터 `*p`</span>
                                <span class="address" id="ptr-array-address">?</span>
                                <span class="value" id="ptr-array-value">?</span>
                            </div>
                            <p id="ptr-array-log" class="font-mono p-2 bg-blue-100 text-blue-800 rounded-md h-full flex items-center justify-center"></p>
                        </div>
                         <div class="mt-6 flex flex-wrap gap-3 justify-center">
                            <button id="ptr-array-init" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">1. 포인터 초기화 (`p = arr`)</button>
                            <button id="ptr-array-inc" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition" disabled>2. 포인터 증가 (`p++`)</button>
                            <button id="ptr-array-reset" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">초기화</button>
                        </div>
                    </div>
                     <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 2</h4>
                        <p class="mt-2 text-gray-700">1. `int num = 10;` 변수와 `int *ptr;` 포인터를 만드세요.<br>2. `ptr`이 `num`을 가리키도록 한 뒤, `ptr`을 이용해서 `num`의 값을 50으로 변경하고 `num`의 값을 출력하여 확인하세요.<br>3. (심화) 정수 배열을 선언하고 포인터를 이용해 반복문을 돌면서 배열의 모든 요소에 5를 더하는 코드를 작성하세요.</p>
                    </div>
                </section>

                <!-- Part 3: 2D Array --><section id="part3" class="mb-16 scroll-mt-20">
                     <h2 class="text-3xl font-bold mb-2">Part 3. 2차원 배열: 데이터 바둑판 ▦</h2>
                    <p class="text-lg text-gray-600 mb-6">1차원 배열의 묶음인 2차원 배열은 행과 열의 구조를 가집니다. 엑셀 시트나 게임 맵처럼 격자 형태의 데이터를 다룰 때 매우 유용합니다.</p>
                     <div class="interactive-box">
                        <h3 class="text-xl font-semibold mb-4">2차원 배열 시각화</h3>
                        <p class="mb-4">3x4 크기의 2차원 배열입니다. 각 칸에 마우스를 올려 행과 열 인덱스, 그리고 값을 확인해보세요.</p>
                        <div id="matrix-viz" class="p-4 bg-gray-50 rounded-lg"></div>
                        <div id="matrix-tooltip" class="mt-4 text-center font-mono p-2 bg-green-100 text-green-800 rounded-md h-10 flex items-center justify-center"></div>
                    </div>
                     <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 3</h4>
                        <p class="mt-2 text-gray-700">3x3 크기의 2차원 배열 2개를 만들고, 두 행렬의 같은 위치 요소끼리 더한 결과를 새로운 2차원 배열에 저장하여 출력하는 프로그램을 작성해보세요.</p>
                    </div>
                </section>

                <!-- Part 4: Functions --><section id="part4" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 4. 함수: 기능별 마법 상자 ⚙️</h2>
                    <p class="text-lg text-gray-600 mb-6">함수는 특정 작업을 수행하는 코드 덩어리를 묶어 이름을 붙인 것입니다. 코드를 재사용하고, 프로그램을 기능별로 깔끔하게 정리할 수 있게 해주는 C언어의 핵심입니다. 함수의 여러 유형을 단계별로 알아봅시다.</p>
                    <div class="space-y-8">
                        <div>
                            <h3 class="text-2xl font-bold mb-4">4.1. 가장 간단한 함수: 입력 X, 반환값 X</h3>
                            <p class="mb-4">가장 기본적인 형태로, 정해진 동작만 수행하고 끝나는 함수입니다. 마치 버튼을 누르면 항상 같은 멜로디가 나오는 벨과 같습니다.</p>
                            <div class="code-block">#include &lt;stdio.h&gt;

// "Hello, Function!"을 출력하는 함수 정의
void say_hello() {
    printf("Hello, Function!\n");
}

int main() {
    say_hello(); // 함수 이름으로 호출!
    return 0;
}</div>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold mb-4">4.2. 재료를 받는 함수: 입력 O, 반환값 X</h3>
                            <p class="mb-4">외부에서 데이터(재료)를 받아 작업을 수행하는 함수입니다. 자판기에 동전을 넣으면 정해진 음료수가 나오는 것과 비슷하죠. 여기서 데이터를 전달하는 방식을 <b class="text-indigo-600">Call by Value (값에 의한 호출)</b>라고 합니다. 원본 데이터의 '값'만 복사해서 전달하므로, 함수 안에서 데이터를 바꿔도 원본은 안전하게 유지됩니다.</p>
                            <div class="code-block">#include &lt;stdio.h&gt;

// 정수 하나를 받아서 해당 단의 구구단을 출력하는 함수
void print_gugudan(int dan) { // dan이라는 이름으로 정수 값을 복사해옴
    printf("--- %d단 ---\n", dan);
    for (int i = 1; i <= 9; i++) {
        printf("%d * %d = %d\n", dan, i, dan * i);
    }
}

int main() {
    print_gugudan(7); // 7이라는 '값'을 전달
    return 0;
}</div>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold mb-4">4.3. 결과물을 돌려주는 함수: 입력 O, 반환값 O</h3>
                            <p class="mb-4">데이터를 받아 계산한 뒤, 그 결과물을 함수를 호출한 곳으로 돌려주는 가장 표준적인 함수입니다. 계산기에 숫자를 입력하고 '='를 누르면 결과가 화면에 표시되는 것과 같습니다. `return` 키워드를 사용해 결과값을 반환합니다.</p>
                             <div class="code-block">#include &lt;stdio.h&gt;

// 두 정수를 더한 결과를 반환하는 함수
int add_numbers(int num1, int num2) {
    int sum = num1 + num2;
    return sum; // 계산된 결과값 sum을 돌려줌
}

int main() {
    int result = add_numbers(5, 10); // 함수가 돌려준 값을 result 변수에 저장
    printf("계산 결과: %d\n", result); // 15 출력
    return 0;
}</div>
                        </div>
                    </div>
                     <div class="interactive-box mt-10">
                        <h3 class="text-xl font-semibold mb-4 text-center">핵심 비교: 값 전달 vs 주소 전달</h3>
                        <p class="text-center mb-6">함수에 값을 넘기는 방식(Call by Value)과 주소를 넘기는 방식(Call by Reference)의 가장 큰 차이점은 '원본 데이터의 변경 가능 여부'입니다. 아래 시뮬레이션으로 그 차이를 직접 확인해보세요.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div>
                                <h4 class="font-bold text-center mb-2">Call by Value (값 복사)</h4>
                                <div class="p-4 bg-gray-50 rounded-lg">
                                    <div class="memory-box mb-2">
                                        <span class="font-semibold">main: `num`</span>
                                        <span class="value" id="cbv-main-val">5</span>
                                    </div>
                                    <div class="memory-box bg-blue-50">
                                        <span class="font-semibold">함수: `n`</span>
                                        <span class="value" id="cbv-func-val">?</span>
                                    </div>
                                </div>
                                <button id="cbv-run" class="w-full mt-4 bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">함수 호출</button>
                                <p id="cbv-log" class="mt-2 text-center text-sm h-5"></p>
                            </div>
                             <div>
                                <h4 class="font-bold text-center mb-2">Call by Reference (주소 참조)</h4>
                                 <div class="p-4 bg-gray-50 rounded-lg">
                                    <div class="memory-box mb-2">
                                        <span class="font-semibold">main: `x`</span>
                                        <span class="value" id="cbr-main-val">10</span>
                                    </div>
                                    <div class="memory-box bg-green-50">
                                        <span class="font-semibold">함수: `*a` (x의 주소 참조)</span>
                                        <span class="value" id="cbr-func-val">?</span>
                                    </div>
                                </div>
                                <button id="cbr-run" class="w-full mt-4 bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">Swap 함수 호출</button>
                                <p id="cbr-log" class="mt-2 text-center text-sm h-5"></p>
                            </div>
                        </div>
                    </div>
                    <div class="mt-8">
                        <h3 class="text-2xl font-bold mb-4">4.4. 원본을 바꾸는 함수: 포인터 매개변수</h3>
                        <p class="mb-4">함수 안에서 `main` 함수에 있는 원본 변수의 값을 직접 바꾸고 싶을 때 사용합니다. 이때는 변수의 '값'이 아닌 변수의 '주소'를 알려주는 포인터를 사용하며, 이를 <b class="text-indigo-600">Call by Reference (참조에 의한 호출)</b>라고 합니다.</p>
                        <div class="code-block">#include &lt;stdio.h&gt;

// 두 변수의 '주소'를 받아 값을 직접 교환하는 swap 함수
void swap(int *a, int *b) { // a와 b는 각각 정수 변수의 주소를 담는 포인터
    int temp = *a;  // a 주소에 있는 '값'을 temp에 저장
    *a = *b;      // b 주소의 '값'을 a 주소에 저장
    *b = temp;    // temp의 값을 b 주소에 저장
}

int main() {
    int x = 10, y = 20;
    printf("Swap 전: x=%d, y=%d\n", x, y);
    
    swap(&x, &y); // x와 y의 '값'이 아닌 '주소(&)'를 함수에 전달
    
    printf("Swap 후: x=%d, y=%d\n", x, y); // 원본 변수의 값이 바뀜!
    return 0;
}</div>
                    </div>
                     <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 4</h4>
                        <p class="mt-2 text-gray-700">정수 배열과 그 크기를 인자로 받아서, 배열의 모든 요소의 합을 반환하는 `sum_array()` 함수를 작성해보세요.</p>
                    </div>
                </section>

                <!-- Part 5: Recursion --><section id="part5" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 5. 함수 심화: 재귀 🔄</h2>
                    <p class="text-lg text-gray-600 mb-6">재귀 함수는 자기 자신을 다시 호출하여 문제를 해결하는 강력한 프로그래밍 기법입니다. 복잡한 문제를 간단한 규칙으로 풀어내는 재귀의 세계를 탐험해봅시다.</p>
                    <div class="interactive-box mb-8">
                        <h3 class="text-xl font-semibold mb-4">하노이의 탑</h3>
                        <p class="mb-4">원판 개수를 선택하고 '시작' 버튼을 눌러 하노이의 탑 재귀 알고리즘이 어떻게 작동하는지 시각적으로 확인하세요.</p>
                        <div class="flex items-center justify-center gap-4 mb-4">
                            <label for="hanoi-disks">원판 개수:</label>
                            <select id="hanoi-disks" class="border rounded px-2 py-1">
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                            </select>
                            <button id="hanoi-start" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">시작</button>
                            <button id="hanoi-reset" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">초기화</button>
                        </div>
                        <canvas id="hanoi-canvas" width="600" height="250" class="mx-auto hanoi-canvas"></canvas>
                        <p id="hanoi-log" class="mt-2 text-center font-mono p-2 bg-purple-100 text-purple-800 rounded-md h-10 flex items-center justify-center"></p>
                    </div>
                    <div class="interactive-box">
                        <h3 class="text-xl font-semibold mb-4">피보나치와 메모이제이션</h3>
                        <p class="mb-4">같은 재귀 문제도 메모이제이션(Memoization) 기법을 사용하면 성능이 극적으로 향상됩니다. n번째 피보나치 수를 계산할 때, 두 방식의 함수 호출 횟수를 비교해보세요.</p>
                         <div class="flex items-center justify-center gap-4 mb-4">
                            <label for="fib-n">n 값:</label>
                            <input type="number" id="fib-n" value="10" min="1" max="20" class="border rounded px-2 py-1 w-20 text-center">
                            <button id="fib-calc" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">계산</button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                            <div>
                                <h4 class="font-bold">일반 재귀</h4>
                                <p class="text-2xl font-bold" id="fib-normal-calls">-</p>
                                <p class="text-sm text-gray-500">호출 횟수</p>
                            </div>
                             <div>
                                <h4 class="font-bold">메모이제이션</h4>
                                <p class="text-2xl font-bold" id="fib-memo-calls">-</p>
                                <p class="text-sm text-gray-500">호출 횟수</p>
                            </div>
                        </div>
                        <div class="mt-4 chart-container">
                            <canvas id="fib-chart"></canvas>
                        </div>
                    </div>
                    <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 5</h4>
                         <p class="mt-2 text-gray-700">1. 양의 정수 `n`을 인자로 받아서 `n!` (팩토리얼)을 계산하는 재귀 함수 `factorial()`을 작성하세요. (힌트: `n! = n * (n-1)!` 이고, `0! = 1` 입니다.)</p>
                         <p class="mt-2 text-gray-700">2. (도전 과제) 하노이의 탑 코드에서 원판의 개수가 4개일 때, 총 몇 번의 이동이 발생하는지 직접 세어보고, `hanoi` 함수 내에 `count` 변수를 사용하여 프로그램이 이동 횟수를 직접 세도록 코드를 수정해보세요.</p>
                    </div>
                </section>
                
                <!-- Part 6: Struct & Union --><section id="part6" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 6. 구조체 & 공용체: 데이터 묶음과 공간 절약 📦</h2>
                    <p class="text-lg text-gray-600 mb-6">C언어에서 여러 종류의 데이터를 하나의 논리적인 단위로 묶는 방법인 구조체(`struct`)와 공용체(`union`)에 대해 알아봅시다. 이들은 복잡한 데이터를 다루거나 메모리 효율을 높일 때 유용하게 사용됩니다.</p>
                    <h3 class="text-2xl font-bold mt-8 mb-4">6.1. 구조체 (Structure): 다양한 데이터의 묶음</h3>
                    <p class="mb-4">구조체는 서로 다른 자료형의 변수들을 하나로 묶어 새로운 자료형을 정의하는 방식입니다. 마치 학생의 이름, 학번, 점수 등 여러 정보를 하나의 '학생 정보' 묶음으로 만드는 것과 같습니다.</p>
                    <div class="code-block">#include &lt;stdio.h&gt;
#include &lt;string.h&gt; // strcpy 함수 사용

// 학생 성적 정보를 담는 구조체 정의
struct myGrade {
    char name[20]; // 이름 (20바이트 문자 배열)
    int korean;    // 국어 점수 (4바이트 정수)
    int english;   // 영어 점수 (4바이트 정수)
    int math;      // 수학 점수 (4바이트 정수)
};

int main() {
    // myGrade 타입의 변수 student1 선언
    struct myGrade student1;

    // 멤버 접근 및 값 할당
    strcpy(student1.name, "김철수"); // 문자열 복사는 strcpy 사용
    student1.korean = 90;
    student1.english = 85;
    student1.math = 92;

    printf("학생 이름: %s\n", student1.name);
    printf("국어: %d, 영어: %d, 수학: %d\n", 
           student1.korean, student1.english, student1.math);
           
    // 구조체의 크기 (name 20바이트 + int 3개 * 4바이트 = 20 + 12 = 32바이트. 
    // 실제로는 메모리 정렬(padding) 때문에 더 커질 수 있습니다.)
    printf("struct myGrade의 크기: %lu 바이트\n", sizeof(struct myGrade));

    return 0;
}</div>
                    <div class="interactive-box mt-8">
                        <h4 class="text-xl font-semibold mb-4 text-center">구조체 배열로 반 학생 표현하기</h4>
                        <p class="mb-4 text-center">여러 학생의 정보를 구조체 배열로 관리할 수 있습니다. 각 칸이 하나의 학생 정보 묶음입니다.</p>
                        <div class="mt-6 text-center">
                            <img src="https://storage.googleapis.com/aai-web-samples/c-struct-array.png" alt="구조체 배열 시각화" class="mx-auto rounded-lg shadow-md">
                            <p class="font-bold text-lg mt-4">💡 시각화: 구조체 배열로 표현된 반 학생들</p>
                        </div>
                    </div>
                    <h3 class="text-2xl font-bold mt-12 mb-4">6.2. 공용체 (Union): 메모리 공간 재활용</h3>
                    <p class="mb-4">공용체는 구조체와 비슷하게 여러 자료형을 묶을 수 있지만, 모든 멤버가 **같은 메모리 공간을 공유**한다는 점이 다릅니다. 이는 메모리 공간을 절약할 때 사용되며, 한 번에 하나의 멤버만 값을 가질 수 있습니다.</p>
                    <div class="code-block">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 다양한 종류의 데이터를 담을 수 있는 공용체 정의
union Data {
    int i;        // 정수형 (4바이트)
    float f;      // 실수형 (4바이트)
    char str[20]; // 문자열 (20바이트 문자 배열)
};

int main() {
    union Data data; // Data 타입의 공용체 변수 data 선언

    printf("union Data의 크기: %lu 바이트\n", sizeof(union Data)); 
    // 가장 큰 멤버인 str[20]의 크기인 20바이트가 할당됩니다.

    // 1. 정수 값을 할당하고 출력
    data.i = 10;
    printf("data.i: %d\n", data.i); // 10
    // 이 시점에 data.f나 data.str의 값은 유효하지 않습니다.

    // 2. 실수 값을 할당하고 출력
    data.f = 22.5;
    printf("data.f: %.1f\n", data.f); // 22.5
    // 이 시점에 data.i나 data.str의 값은 유효하지 않습니다.
    // (이전 data.i 값 10은 사라짐)

    // 3. 문자열 값을 할당하고 출력
    strcpy(data.str, "C Language");
    printf("data.str: %s\n", data.str); // C Language
    // 이 시점에 data.i나 data.f의 값은 유효하지 않습니다.
    // (이전 data.f 값 22.5는 사라짐)
    
    return 0;
}</div>
                    <div class="interactive-box mt-8">
                        <h4 class="text-xl font-semibold mb-4 text-center">공용체 메모리 공간 시각화</h4>
                        <p class="mb-4 text-center">공용체는 가장 큰 멤버의 크기만큼만 메모리를 할당받아 공유합니다. 활성화 버튼을 눌러보세요.</p>
                        <div class="union-container">
                             <div class="mt-6 text-center">
                                 <img src="https://storage.googleapis.com/aai-web-samples/c-union-memory.png" alt="공용체 메모리 시각화" class="mx-auto rounded-lg shadow-md">
                                <p class="font-bold text-lg mt-4">💡 시각화: 공용체의 메모리 공유</p>
                            </div>
                            <div class="union-memory-slot w-full max-w-sm mt-4">
                                <span class="label">공유 메모리 공간</span>
                                <div id="union-current-value" class="current-value"></div>
                                <p id="union-active-member" class="text-sm text-gray-700 mt-2"></p>
                            </div>
                            <div class="mt-4 flex flex-wrap gap-3 justify-center">
                                <button id="union-set-int" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition">정수 (int)</button>
                                <button id="union-set-float" class="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600 transition">실수 (float)</button>
                                <button id="union-set-string" class="bg-purple-500 text-white px-4 py-2 rounded-md hover:bg-purple-600 transition">문자열 (char[20])</button>
                            </div>
                        </div>
                    </div>
                    <h3 class="text-2xl font-bold mt-12 mb-4">6.3. 구조체 vs 공용체: 메모리 공간 비교</h3>
                    <p class="mb-4">가장 큰 차이점은 메모리 할당 방식입니다. 구조체는 모든 멤버가 독립적인 공간을 가지지만, 공용체는 가장 큰 멤버의 크기만큼만 공간을 할당받아 모든 멤버가 이 공간을 공유합니다.</p>
                    <div class="p-6 bg-blue-50 border-l-4 border-blue-400 mb-6">
                        <h4 class="font-bold text-lg">구조체 메모리 (예시 `struct myGrade`)</h4>
                        <p class="mt-2 text-gray-700">`char name[20]` (20 bytes) + `int korean` (4 bytes) + `int english` (4 bytes) + `int math` (4 bytes)</p>
                        <p class="mt-1 text-gray-700 font-bold">총 최소 32 바이트 (메모리 정렬에 따라 더 커질 수 있음)</p>
                        <p class="mt-4 text-gray-700">각 멤버가 동시에 값을 가질 수 있습니다.</p>
                    </div>
                    <div class="p-6 bg-purple-50 border-l-4 border-purple-400">
                        <h4 class="font-bold text-lg">공용체 메모리 (예시 `union Data`)</h4>
                        <p class="mt-2 text-gray-700">`int i` (4 bytes), `float f` (4 bytes), `char str[20]` (20 bytes) 중 **가장 큰 크기**</p>
                        <p class="mt-1 text-gray-700 font-bold">총 20 바이트</p>
                        <p class="mt-4 text-gray-700">한 번에 하나의 멤버만 유효한 값을 가질 수 있으며, 다른 멤버에 값을 할당하면 이전 멤버의 값이 손상됩니다.</p>
                    </div>
                    <div class="mt-8 p-6 bg-indigo-50 border-l-4 border-indigo-400">
                        <h4 class="font-bold text-lg">🧑‍💻 실습 문제 6</h4>
                        <p class="mt-2 text-gray-700">1. 다음과 같은 정보를 담는 구조체 `struct Book { char title[50]; char author[30]; int year; };`를 정의하고, `Book` 타입 변수를 선언하여 값을 할당하고 출력해보세요.</p>
                        <p class="mt-2 text-gray-700">2. (심화) 구조체 `struct Point { int x; int y; };`와 이 구조체를 인자로 받아 두 점 사이의 거리를 계산하는 함수 `calculate_distance(struct Point p1, struct Point p2)`를 작성해보세요. (힌트: `sqrt`, `pow` 함수는 `math.h`에 있습니다.)</p>
                    </div>
                </section>

                <!-- Part 7: Data Structures Intro --><section id="part7" class="mb-16 scroll-mt-20">
                    <h2 class="text-3xl font-bold mb-2">Part 7. 동적 자료구조 입문 ⛓️</h2>
                    <p class="text-lg text-gray-600 mb-6">배열은 크기가 고정되어 있지만, 포인터를 사용하면 프로그램 실행 중에 크기가 변하는 '동적' 자료구조를 만들 수 있습니다. 가장 대표적인 세 가지의 기본 원리를 알아봅시다.</p>
                    <div class="interactive-box mb-8">
                        <h3 class="text-xl font-semibold mb-4">연결 리스트 (Linked List)</h3>
                        <p class="mb-4">데이터와 다음 노드를 가리키는 포인터를 묶은 '노드'들이 기차처럼 연결된 구조입니다. 필요할 때마다 칸(노드)을 추가하거나 뺄 수 있어 유연합니다.</p>
                        <div id="ll-viz" class="ds-viz">
                             <div class="ds-node">HEAD</div>
                        </div>
                        <div class="mt-4 flex flex-wrap gap-3 justify-center">
                            <button id="ll-add" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">노드 추가</button>
                            <button id="ll-remove" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">노드 삭제</button>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div class="interactive-box">
                            <h3 class="text-xl font-semibold mb-4 text-center">스택 (Stack) - LIFO</h3>
                            <p class="mb-4 text-center text-sm">마지막에 들어온 것이 가장 먼저 나갑니다. (Last-In, First-Out)</p>
                            <div id="stack-viz" class="ds-viz stack-viz"></div>
                             <div class="mt-4 flex flex-wrap gap-3 justify-center">
                                <button id="stack-push" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">Push</button>
                                <button id="stack-pop" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">Pop</button>
                            </div>
                        </div>
                         <div class="interactive-box">
                            <h3 class="text-xl font-semibold mb-4 text-center">큐 (Queue) - FIFO</h3>
                            <p class="mb-4 text-center text-sm">가장 먼저 들어온 것이 가장 먼저 나갑니다. (First-In, First-Out)</p>
                            <div id="queue-viz" class="ds-viz"></div>
                             <div class="mt-4 flex flex-wrap gap-3 justify-center">
                                <button id="queue-enq" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">Enqueue</button>
                                <button id="queue-deq" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition">Dequeue</button>
                            </div>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </main>

    <!-- 푸터 -->
    <footer class="text-center py-8 mt-10">
        <p class="text-sm text-slate-500">연락처: thiskorea@cberi.go.kr</p>
    </footer>

    <!-- 통합된 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Part 1: 1D Array Visualization ---
            const arrayData = [88, 95, 76, 100, 81];
            const arrayViz = document.getElementById('array-viz');
            const arrayTooltip = document.getElementById('array-tooltip');
            
            arrayData.forEach((value, index) => {
                const cell = document.createElement('div');
                cell.className = 'w-16 h-16 border-2 border-gray-400 flex items-center justify-center text-lg font-bold bg-white transition cursor-pointer hover:bg-indigo-500 hover:text-white';
                cell.textContent = value;
                cell.dataset.index = index;
                cell.dataset.value = value;
                arrayViz.appendChild(cell);

                cell.addEventListener('mouseenter', (e) => {
                    const idx = e.target.dataset.index;
                    const val = e.target.dataset.value;
                    arrayTooltip.textContent = `index: ${idx}, value: ${val}`;
                });
            });
             arrayViz.addEventListener('mouseleave', () => {
                arrayTooltip.textContent = '마우스를 올려 인덱스와 값을 확인하세요.';
            });
             arrayTooltip.textContent = '마우스를 올려 인덱스와 값을 확인하세요.';

            // --- Part 2: Pointer Interaction ---
            const treasureValueEl = document.getElementById('treasure-value');
            const treasureAddressEl = document.getElementById('treasure-address');
            const pmapValueEl = document.getElementById('pmap-value');
            const pmapAddressEl = document.getElementById('pmap-address');
            const ptrLog = document.getElementById('ptr-log');
            const ptrStep1 = document.getElementById('ptr-step1');
            const ptrStep2 = document.getElementById('ptr-step2');
            const ptrReset = document.getElementById('ptr-reset');

            const treasureAddress = `0x${Math.floor(Math.random() * (2**16)).toString(16).padStart(4,'0')}`;
            const pmapAddress = `0x${Math.floor(Math.random() * (2**16)).toString(16).padStart(4,'0')}`;

            function resetPointerDemo() {
                treasureValueEl.textContent = '100';
                treasureAddressEl.textContent = `주소: ${treasureAddress}`;
                pmapValueEl.textContent = '?';
                pmapAddressEl.textContent = `주소: ${pmapAddress}`;
                ptrLog.textContent = '초기 상태입니다.';
                ptrStep1.disabled = false;
                ptrStep2.disabled = true;
            }

            ptrStep1.addEventListener('click', () => {
                pmapValueEl.textContent = treasureAddress;
                ptrLog.textContent = '`p_map`이 `treasure`의 주소를 가리킵니다.';
                ptrStep1.disabled = true;
                ptrStep2.disabled = false;
            });

            ptrStep2.addEventListener('click', () => {
                treasureValueEl.textContent = '250';
                ptrLog.textContent = '포인터를 통해 원본 값이 변경되었습니다!';
                ptrStep2.disabled = true;
            });
            
            ptrReset.addEventListener('click', resetPointerDemo);
            resetPointerDemo();

            // --- Part 2.1: Pointer and Array Interaction ---
            const ptrArrayData = {
                values: [10, 20, 30, 40, 50],
                addresses: []
            };
            let startAddr = Math.floor(Math.random() * 0x7FFF) * 4 + 0x7FF0000;
            for(let i=0; i < ptrArrayData.values.length; i++) {
                ptrArrayData.addresses.push(`0x${(startAddr + i*4).toString(16)}`);
            }

            const ptrArrayViz = document.getElementById('ptr-array-viz');
            const ptrArrayAddressEl = document.getElementById('ptr-array-address');
            const ptrArrayValueEl = document.getElementById('ptr-array-value');
            const ptrArrayLog = document.getElementById('ptr-array-log');
            const ptrArrayInitBtn = document.getElementById('ptr-array-init');
            const ptrArrayIncBtn = document.getElementById('ptr-array-inc');
            const ptrArrayResetBtn = document.getElementById('ptr-array-reset');
            
            let currentPtrIndex = -1;

            function renderPtrArray() {
                ptrArrayViz.innerHTML = '';
                 ptrArrayData.values.forEach((value, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'w-16 h-16 border-2 border-gray-400 flex items-center justify-center text-lg font-bold bg-white transition';
                    cell.textContent = value;
                    if(index === currentPtrIndex) {
                        cell.classList.add('array-cell-pointer');
                    }
                    ptrArrayViz.appendChild(cell);
                });
            }

            function resetPtrArrayDemo() {
                currentPtrIndex = -1;
                renderPtrArray();
                ptrArrayAddressEl.textContent = '?';
                ptrArrayValueEl.textContent = '?';
                ptrArrayLog.textContent = '포인터가 초기화되지 않았습니다.';
                ptrArrayInitBtn.disabled = false;
                ptrArrayIncBtn.disabled = true;
            }

            ptrArrayInitBtn.addEventListener('click', () => {
                currentPtrIndex = 0;
                renderPtrArray();
                ptrArrayAddressEl.textContent = ptrArrayData.addresses[currentPtrIndex];
                ptrArrayValueEl.textContent = ptrArrayData.values[currentPtrIndex];
                ptrArrayLog.textContent = 'p가 배열의 시작 주소를 가리킵니다.';
                ptrArrayInitBtn.disabled = true;
                ptrArrayIncBtn.disabled = false;
            });
            
            ptrArrayIncBtn.addEventListener('click', () => {
                if (currentPtrIndex < ptrArrayData.values.length - 1) {
                    currentPtrIndex++;
                    renderPtrArray();
                    ptrArrayAddressEl.textContent = ptrArrayData.addresses[currentPtrIndex];
                    ptrArrayValueEl.textContent = ptrArrayData.values[currentPtrIndex];
                    ptrArrayLog.textContent = `p++ 연산. p가 다음 요소를 가리킵니다.`;
                } else {
                    ptrArrayLog.textContent = '배열의 끝에 도달했습니다.';
                    ptrArrayIncBtn.disabled = true;
                }
            });

            ptrArrayResetBtn.addEventListener('click', resetPtrArrayDemo);
            resetPtrArrayDemo();

            // --- Part 3: 2D Array Visualization ---
            const matrixData = [
                [10, 20, 30, 40],
                [50, 60, 70, 80],
                [90, 100, 110, 120]
            ];
            const matrixViz = document.getElementById('matrix-viz');
            const matrixTooltip = document.getElementById('matrix-tooltip');
            
            matrixData.forEach((row, r_idx) => {
                const rowEl = document.createElement('div');
                rowEl.className = 'flex justify-center gap-2 mb-2';
                row.forEach((value, c_idx) => {
                    const cell = document.createElement('div');
                    cell.className = 'w-16 h-16 border-2 border-gray-400 flex items-center justify-center text-lg font-bold bg-white transition cursor-pointer hover:bg-indigo-500 hover:text-white';
                    cell.textContent = value;
                    cell.dataset.index = `[${r_idx}][${c_idx}]`;
                    cell.dataset.value = value;
                    cell.addEventListener('mouseenter', (e) => {
                         matrixTooltip.textContent = `index: ${e.target.dataset.index}, value: ${e.target.dataset.value}`;
                    });
                    rowEl.appendChild(cell);
                });
                matrixViz.appendChild(rowEl);
            });
            matrixViz.addEventListener('mouseleave', () => {
                matrixTooltip.textContent = '마우스를 올려 인덱스와 값을 확인하세요.';
            });
            matrixTooltip.textContent = '마우스를 올려 인덱스와 값을 확인하세요.';
            
            // --- Part 4: Call by Value / Reference ---
            const cbvMainVal = document.getElementById('cbv-main-val');
            const cbvFuncVal = document.getElementById('cbv-func-val');
            const cbvRunBtn = document.getElementById('cbv-run');
            const cbvLog = document.getElementById('cbv-log');

            cbvRunBtn.addEventListener('click', () => {
                cbvMainVal.textContent = '5';
                cbvFuncVal.textContent = '5';
                cbvLog.textContent = '값이 복사되었습니다.';
                setTimeout(() => {
                    cbvFuncVal.textContent = '15';
                    cbvLog.textContent = '함수 내 값 변경...';
                }, 1000);
                setTimeout(() => {
                    cbvLog.textContent = '원본은 바뀌지 않음!';
                }, 2000);
            });

            const cbrMainVal = document.getElementById('cbr-main-val');
            const cbrFuncVal = document.getElementById('cbr-func-val');
            const cbrRunBtn = document.getElementById('cbr-run');
            const cbrLog = document.getElementById('cbr-log');

            cbrRunBtn.addEventListener('click', () => {
                cbrMainVal.textContent = '10';
                cbrFuncVal.textContent = '주소 참조';
                cbrLog.textContent = '주소를 참조합니다.';
                setTimeout(() => {
                    cbrMainVal.textContent = '20'; // In a real swap, another var would be used
                    cbrLog.textContent = '포인터로 원본 값 변경!';
                }, 1500);
            });

            // --- Part 5: Hanoi Tower ---
            const hanoiCanvas = document.getElementById('hanoi-canvas');
            const hanoiCtx = hanoiCanvas.getContext('2d');
            const hanoiStartBtn = document.getElementById('hanoi-start');
            const hanoiResetBtn = document.getElementById('hanoi-reset');
            const hanoiDisksSelect = document.getElementById('hanoi-disks');
            const hanoiLogEl = document.getElementById('hanoi-log');
            let animationFrameId;

            const pegs = [[], [], []];
            const diskColors = ['#E53E3E', '#DD6B20', '#D69E2E', '#38A169', '#3182CE', '#5A67D8', '#805AD5'];
            const pegX = [100, 300, 500];
            const baseY = 230;
            const diskHeight = 20;

            function drawHanoi() {
                hanoiCtx.clearRect(0, 0, hanoiCanvas.width, hanoiCanvas.height);
                hanoiCtx.fillStyle = '#A0AEC0';
                for (let i = 0; i < 3; i++) {
                    hanoiCtx.fillRect(pegX[i] - 5, 50, 10, 180);
                    hanoiCtx.fillRect(pegX[i] - 50, baseY, 100, 10);
                }
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < pegs[i].length; j++) {
                        const disk = pegs[i][j];
                        const diskWidth = disk * 20 + 30;
                        hanoiCtx.fillStyle = diskColors[disk - 1];
                        hanoiCtx.fillRect(pegX[i] - diskWidth / 2, baseY - (j + 1) * diskHeight, diskWidth, diskHeight);
                    }
                }
            }
            
            function resetHanoi() {
                if(animationFrameId) cancelAnimationFrame(animationFrameId);
                const n = parseInt(hanoiDisksSelect.value);
                pegs[0] = []; pegs[1] = []; pegs[2] = [];
                for (let i = n; i > 0; i--) { pegs[0].push(i); }
                hanoiLogEl.textContent = '초기 상태';
                hanoiStartBtn.disabled = false;
                drawHanoi();
            }

            let moveQueue = [];
            function hanoiAlgorithm(n, from, by, to) {
                if (n === 1) {
                    moveQueue.push({ from, to, disk: n });
                    return;
                }
                hanoiAlgorithm(n - 1, from, to, by);
                moveQueue.push({ from, to, disk: n });
                hanoiAlgorithm(n - 1, by, from, to);
            }
            
            function animateMoves() {
                if (moveQueue.length === 0) {
                    hanoiLogEl.textContent = '이동 완료!';
                    hanoiStartBtn.disabled = false;
                    return;
                }
                const move = moveQueue.shift();
                const diskToMove = pegs[move.from][pegs[move.from].length - 1];
                const disk = pegs[move.from].pop();
                pegs[move.to].push(disk);
                hanoiLogEl.textContent = `원판 ${diskToMove}을(를) ${String.fromCharCode(65+move.from)}에서 ${String.fromCharCode(65+move.to)}로 이동`;
                drawHanoi();
                animationFrameId = setTimeout(animateMoves, 500);
            }

            hanoiStartBtn.addEventListener('click', () => {
                resetHanoi();
                moveQueue = [];
                const n = parseInt(hanoiDisksSelect.value);
                hanoiAlgorithm(n, 0, 1, 2);
                hanoiStartBtn.disabled = true;
                animateMoves();
            });
            hanoiResetBtn.addEventListener('click', resetHanoi);
            hanoiDisksSelect.addEventListener('change', resetHanoi);
            resetHanoi();

            // --- Part 5: Fibonacci ---
            const fibN = document.getElementById('fib-n');
            const fibCalcBtn = document.getElementById('fib-calc');
            const fibNormalCallsEl = document.getElementById('fib-normal-calls');
            const fibMemoCallsEl = document.getElementById('fib-memo-calls');
            const fibChartCanvas = document.getElementById('fib-chart');
            let fibChart;
            
            let normalCalls = 0;
            function fibNormal(n) {
                normalCalls++;
                if (n <= 1) return n;
                return fibNormal(n - 1) + fibNormal(n - 2);
            }

            let memoCalls = 0;
            let memo = {};
            function fibMemo(n) {
                memoCalls++;
                if (n in memo) return memo[n];
                if (n <= 1) return n;
                memo[n] = fibMemo(n - 1) + fibMemo(n - 2);
                return memo[n];
            }

            function updateFibChart(normal, memo) {
                const data = {
                    labels: ['함수 호출 횟수'],
                    datasets: [
                        { label: '일반 재귀', data: [normal], backgroundColor: 'rgba(229, 62, 62, 0.6)', borderColor: 'rgba(229, 62, 62, 1)', borderWidth: 1 },
                        { label: '메모이제이션', data: [memo], backgroundColor: 'rgba(56, 161, 105, 0.6)', borderColor: 'rgba(56, 161, 105, 1)', borderWidth: 1 }
                    ]
                };
                if(fibChart) {
                    fibChart.data = data;
                    fibChart.options.scales.y.max = Math.max(normal, memo) * 1.1;
                    fibChart.update();
                } else {
                    fibChart = new Chart(fibChartCanvas, {
                        type: 'bar',
                        data: data,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: { y: { beginAtZero: true, type: 'logarithmic' } },
                            plugins: { title: { display: true, text: '알고리즘별 함수 호출 횟수 비교 (로그 스케일)'} }
                        }
                    });
                }
            }
            
            fibCalcBtn.addEventListener('click', () => {
                const n = parseInt(fibN.value);
                normalCalls = 0;
                fibNormal(n);
                fibNormalCallsEl.textContent = normalCalls.toLocaleString();
                memoCalls = 0;
                memo = {};
                fibMemo(n);
                fibMemoCallsEl.textContent = memoCalls.toLocaleString();
                updateFibChart(normalCalls, memoCalls);
            });
            updateFibChart(0,0);

            // --- Part 6: Union Visualization ---
            const unionCurrentValueEl = document.getElementById('union-current-value');
            const unionActiveMemberEl = document.getElementById('union-active-member');
            const unionSetIntBtn = document.getElementById('union-set-int');
            const unionSetFloatBtn = document.getElementById('union-set-float');
            const unionSetStringBtn = document.getElementById('union-set-string');

            unionSetIntBtn.addEventListener('click', () => {
                unionCurrentValueEl.textContent = '12345';
                unionActiveMemberEl.textContent = '활성화된 멤버: int i';
                unionCurrentValueEl.style.color = '#3B82F6';
            });
            unionSetFloatBtn.addEventListener('click', () => {
                unionCurrentValueEl.textContent = '3.14159';
                unionActiveMemberEl.textContent = '활성화된 멤버: float f';
                unionCurrentValueEl.style.color = '#10B981';
            });
            unionSetStringBtn.addEventListener('click', () => {
                unionCurrentValueEl.textContent = 'HELLO!';
                unionActiveMemberEl.textContent = '활성화된 멤버: char str[20]';
                unionCurrentValueEl.style.color = '#8B5CF6';
            });
            unionCurrentValueEl.textContent = '???';
            unionActiveMemberEl.textContent = '멤버를 선택하세요.';
            unionCurrentValueEl.style.color = '#2C3E50';

            // --- Part 7: Data Structures ---
            const llViz = document.getElementById('ll-viz');
            const llAddBtn = document.getElementById('ll-add');
            const llRemoveBtn = document.getElementById('ll-remove');
            let llCounter = 0;
            llAddBtn.addEventListener('click', () => {
                llCounter++;
                const arrow = document.createElement('span');
                arrow.className = 'ds-arrow';
                arrow.textContent = '→';
                llViz.appendChild(arrow);
                const node = document.createElement('div');
                node.className = 'ds-node';
                node.textContent = llCounter * 10;
                llViz.appendChild(node);
            });
            llRemoveBtn.addEventListener('click', () => {
                if(llCounter > 0) {
                    llViz.removeChild(llViz.lastChild);
                    llViz.removeChild(llViz.lastChild);
                    llCounter--;
                }
            });
            
            const stackViz = document.getElementById('stack-viz');
            const stackPushBtn = document.getElementById('stack-push');
            const stackPopBtn = document.getElementById('stack-pop');
            let stackCounter = 0;
            stackPushBtn.addEventListener('click', () => {
                stackCounter++;
                const item = document.createElement('div');
                item.className = 'ds-item';
                item.textContent = stackCounter;
                stackViz.appendChild(item);
            });
            stackPopBtn.addEventListener('click', () => {
                 if(stackViz.children.length > 0) {
                    stackViz.removeChild(stackViz.lastChild);
                 }
            });
            
            const queueViz = document.getElementById('queue-viz');
            const queueEnqBtn = document.getElementById('queue-enq');
            const queueDeqBtn = document.getElementById('queue-deq');
            let queueCounter = 0;
            queueEnqBtn.addEventListener('click', () => {
                queueCounter++;
                const item = document.createElement('div');
                item.className = 'ds-item mx-1';
                item.textContent = queueCounter;
                queueViz.appendChild(item);
            });
            queueDeqBtn.addEventListener('click', () => {
                if(queueViz.children.length > 0) {
                    queueViz.removeChild(queueViz.firstChild);
                }
            });
        });
    </script>

</body>
</html>
